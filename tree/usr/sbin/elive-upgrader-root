#!/bin/bash
SOURCE="$0"
source /usr/lib/elive-tools/functions
el_make_environment
. gettext.sh
#TEXTDOMAIN="elive-upgrader"
#export TEXTDOMAIN

# Lock system (good one) {{{
lockfile="/tmp/.$(basename $0)-${USER}.lock"
#set -x

exit_ok(){
    rm -f "$lockfile"
}
exit_error(){
    rm -f "$lockfile"
}

if [[ -r "$lockfile" ]] ; then
    PROCCESS="$(cat $lockfile)"
else
    PROCCESS=" "
fi
if (ps up $PROCCESS) 1>/dev/null 2>&1 ; then
    el_error "$(basename $0) already running"
    exit
else
    echo $$ > "$lockfile"
fi

# traps needs to be after the lock verification, in order to not remove it when we are already running
trap "exit_ok" EXIT
trap "exit_error" 1 3 5 6 14 15 ERR TERM

# SET the lock file
echo "$$" > "$lockfile"


# end lock system }}}

update_upgrader(){
    if el_package_update_last_version -c "elive-upgrader" ; then
        if ! apt-get -f install ; then
            el_error "problem with apt-get -f install: $(apt-get -f install )"
            exit 1
        fi
        if ! apt-get update ; then
            if ! apt-get update ; then
                el_error "problem updating package lists: $(apt-get update)"
                exit 1
            fi
        fi
        if ! DEBIAN_FRONTEND=noninteractive apt-get install -q -y elive-upgrader ; then
            el_error "problem upgrading elive-upgrader: $(apt-get install -y elive-upgrader )"
            exit 1
        fi
    else
        el_debug "no new version of elive-ugprader found"
        exit 0
    fi

    #DISPLAY="" el_package_update_last_version -c "elive-upgrader"
}

main(){
    # pre {{{

    hooks_d="/usr/lib/elive-upgrader/hooks"


    # }}}
    # never run on live mode {{{
    if grep -qs "boot=live" /proc/cmdline ; then
        exit
    fi

    # }}}

    # get versions {{{
    version_elive="$( cat "/etc/elive-version" | grep "elive-version:" | awk '{print $2}' )"
    version_upgrader="$( cat "/etc/elive-version" | grep "elive-fixes:" | awk '{print $2}' )"
    version_last_hook="$( find "${hooks_d}" -mindepth 1 -maxdepth 1 -type d | sed -e 's|^.*/||g' | sort -n | tail -1 )"
    read -r version_elive <<< "$version_elive"
    read -r version_upgrader <<< "$version_upgrader"

    # first time, our system is fixed up to the actual version of elive, so nothing more is needed to do until there's a newer version of the tool
    if [[ -z "$version_upgrader" ]] ; then
        version_upgrader="$version_elive"
        echo -e "elive-fixes: $version_upgrader" >> /etc/elive-version
    fi

    # - # get versions }}}

    for arg in "$@"
    do
        case "$arg" in
            #--delayed)
                #is_delayed=1
                #shift
                #;;
            --update)
                update_upgrader
                ;;
        esac
    done


    # migration upgrade cases (auto hooks): {{{
    if LC_ALL=C dpkg --compare-versions "$version_last_hook" "gt" "$version_upgrader" ; then
        while read -ru 3 version
        do
            [[ -z "$version" ]] && continue

            if LC_ALL=C dpkg --compare-versions "$version" "gt" "$version_upgrader" ; then
                el_info "elive-upgrader: hook version: $version"

                while read -ru 3 file
                do
                    case "$file" in
                        *.sh)
                            # script
                            if [[ -x "$file" ]] && [[ "$file" = *".sh" ]] ; then
                                el_info "running script: $file"
                                if ! "$file" ; then
                                    el_error "failed ${file}: $( "$file" )"
                                fi
                            fi
                            ;;
                        *CHANGELOG.txt)
                            # changelog
                            if [[ -s "$file" ]] && [[ "$file" = *"/CHANGELOG.txt" ]] ; then
                                # update: user don't needs to see any version number here
                                #changelog="${changelog}\n\nVersion ${version}:\n$(cat "$file" )"
                                changelog="${changelog}\n\n$(cat "$file" )"
                            fi
                            ;;
                        *)
                            el_error "elive-upgrader: filetype unknown: $file"
                            ;;
                    esac
                done 3<<< "$( find "${hooks_d}/${version}/root" -mindepth 1 -maxdepth 1 -type f )"

                # update version, to know that we have run the hooks until here
                sed -i "/^elive-fixes:/s/^.*$/elive-fixes: ${version}/" "/etc/elive-version"
                version_upgrader="$version"
            fi
        done 3<<< "$( find "${hooks_d}" -mindepth 1 -maxdepth 1 -type d | sed -e 's|^.*/||g' | sort -n )"
    fi

    # changelog to show?
    if [[ -n "$changelog" ]] ; then
        local message_upgraded
        message_upgraded="$( printf "$( eval_gettext "Your Elive has been upgraded with:" )" "" )"

        echo -e "${message_upgraded}$changelog" | zenity --text-info --title="Elive System Updated"
        unset changelog
    fi

    # }}}

    #if ((is_delayed)) ; then
        #el_debug "delayed 20 seconds"
        #sleep 20
    #fi

    # test
    #zenity --info --text="Hello world, im $(whoami) as $UID living in $HOME"

}

#
#  MAIN
#
main "$@"

# vim: set foldmethod=marker :
